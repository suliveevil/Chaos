/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AchievementsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  achievedAchievementIDs: [],
  notesCreated: 0,
  notesDeleted: 0,
  internalLinksCreated: 0,
  commandPaletteOpened: 0,
  quickSwitcherOpened: 0,
  calloutsCreated: 0,
  headingLevelsCreated: 0,
  tagsCreated: 0
};

// src/settings-tab/SettingsTab.ts
var import_obsidian3 = require("obsidian");

// src/reset-progress-modal/ResetProgressModal.ts
var import_obsidian2 = require("obsidian");

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  const saved_component = current_component;
  do {
    while (flushidx < dirty_components.length) {
      const component = dirty_components[flushidx];
      flushidx++;
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance6, create_fragment6, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance6 ? instance6(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment6 ? create_fragment6($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// src/store.ts
var plugin = writable();
var store_default = { plugin };

// node_modules/obsidian-svelte/Icon/useIcon.js
var import_obsidian = require("obsidian");

// node_modules/obsidian-svelte/Button/Button.svelte
function add_css(target) {
  append_styles(target, "svelte-12xcpmj", "button.svelte-12xcpmj{gap:var(--size-4-1)}.mod-plain.svelte-12xcpmj{background:none;box-shadow:none;border:none;color:var(--text-muted)}.mod-plain.svelte-12xcpmj:hover{color:var(--text-normal)}.disabled.svelte-12xcpmj{opacity:0.6}");
}
function create_fragment(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr(button, "aria-label", ctx[2]);
      button.disabled = ctx[1];
      attr(button, "class", "svelte-12xcpmj");
      toggle_class(button, "mod-cta", ctx[0] === "primary");
      toggle_class(button, "mod-warning", ctx[0] === "destructive");
      toggle_class(button, "mod-plain", ctx[0] === "plain");
      toggle_class(button, "disabled", ctx[1]);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[5]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 4) {
        attr(button, "aria-label", ctx2[2]);
      }
      if (!current || dirty & 2) {
        button.disabled = ctx2[1];
      }
      if (!current || dirty & 1) {
        toggle_class(button, "mod-cta", ctx2[0] === "primary");
      }
      if (!current || dirty & 1) {
        toggle_class(button, "mod-warning", ctx2[0] === "destructive");
      }
      if (!current || dirty & 1) {
        toggle_class(button, "mod-plain", ctx2[0] === "plain");
      }
      if (!current || dirty & 2) {
        toggle_class(button, "disabled", ctx2[1]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant = "default" } = $$props;
  let { disabled = false } = $$props;
  let { tooltip = "" } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(0, variant = $$props2.variant);
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("tooltip" in $$props2)
      $$invalidate(2, tooltip = $$props2.tooltip);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [variant, disabled, tooltip, $$scope, slots, click_handler];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { variant: 0, disabled: 1, tooltip: 2 }, add_css);
  }
};
var Button_default = Button;

// node_modules/obsidian-svelte/Setting/SettingItem.svelte
function add_css2(target) {
  append_styles(target, "svelte-17mpvkc", ".vertical.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1)}.vertical-control.svelte-17mpvkc{flex-direction:column;align-items:flex-start;gap:var(--size-4-1);width:100%}");
}
function create_fragment2(ctx) {
  var _a, _b;
  let div4;
  let div2;
  let div0;
  let t0_value = ((_a = ctx[0]) != null ? _a : "") + "";
  let t0;
  let t1;
  let div1;
  let t2_value = ((_b = ctx[1]) != null ? _b : "") + "";
  let t2;
  let t3;
  let div3;
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div3 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "setting-item-name");
      attr(div1, "class", "setting-item-description");
      attr(div2, "class", "setting-item-info");
      attr(div3, "class", "setting-item-control svelte-17mpvkc");
      toggle_class(div3, "vertical-control", ctx[2]);
      attr(div4, "class", "setting-item svelte-17mpvkc");
      toggle_class(div4, "vertical", ctx[2]);
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div1, t2);
      append(div4, t3);
      append(div4, div3);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      var _a2, _b2;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ((_a2 = ctx2[0]) != null ? _a2 : "") + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 2) && t2_value !== (t2_value = ((_b2 = ctx2[1]) != null ? _b2 : "") + ""))
        set_data(t2, t2_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[3], !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null), null);
        }
      }
      if (!current || dirty & 4) {
        toggle_class(div3, "vertical-control", ctx2[2]);
      }
      if (!current || dirty & 4) {
        toggle_class(div4, "vertical", ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name = void 0 } = $$props;
  let { description = void 0 } = $$props;
  let { vertical = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("description" in $$props2)
      $$invalidate(1, description = $$props2.description);
    if ("vertical" in $$props2)
      $$invalidate(2, vertical = $$props2.vertical);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [name, description, vertical, $$scope, slots];
}
var SettingItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, description: 1, vertical: 2 }, add_css2);
  }
};
var SettingItem_default = SettingItem;

// src/reset-progress-modal/ResetProgressModal.svelte
function create_default_slot_1(ctx) {
  let t;
  return {
    c() {
      t = text("Cancel");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot(ctx) {
  let t;
  return {
    c() {
      t = text("Reset");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_fragment3(ctx) {
  let h2;
  let t1;
  let p0;
  let t3;
  let p1;
  let t5;
  let div;
  let button0;
  let t6;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  button0.$on("click", function() {
    if (is_function(ctx[0]))
      ctx[0].apply(this, arguments);
  });
  button1 = new Button_default({
    props: {
      variant: "destructive",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  button1.$on("click", function() {
    if (is_function(ctx[1]))
      ctx[1].apply(this, arguments);
  });
  return {
    c() {
      h2 = element("h2");
      h2.textContent = "Reset Progress";
      t1 = space();
      p0 = element("p");
      p0.textContent = "Resets all achievement progress. THIS CANNOT BE UNDONE.";
      t3 = space();
      p1 = element("p");
      p1.textContent = "Are you sure you want to continue?";
      t5 = space();
      div = element("div");
      create_component(button0.$$.fragment);
      t6 = space();
      create_component(button1.$$.fragment);
      attr(div, "class", "achievements-plugin__reset-modal__button-container");
    },
    m(target, anchor) {
      insert(target, h2, anchor);
      insert(target, t1, anchor);
      insert(target, p0, anchor);
      insert(target, t3, anchor);
      insert(target, p1, anchor);
      insert(target, t5, anchor);
      insert(target, div, anchor);
      mount_component(button0, div, null);
      append(div, t6);
      mount_component(button1, div, null);
      current = true;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      const button0_changes = {};
      if (dirty & 4) {
        button0_changes.$$scope = { dirty, ctx };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 4) {
        button1_changes.$$scope = { dirty, ctx };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h2);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(p0);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(p1);
      if (detaching)
        detach(t5);
      if (detaching)
        detach(div);
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { close } = $$props;
  let { closeAndReset } = $$props;
  $$self.$$set = ($$props2) => {
    if ("close" in $$props2)
      $$invalidate(0, close = $$props2.close);
    if ("closeAndReset" in $$props2)
      $$invalidate(1, closeAndReset = $$props2.closeAndReset);
  };
  return [close, closeAndReset];
}
var ResetProgressModal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { close: 0, closeAndReset: 1 });
  }
};
var ResetProgressModal_default = ResetProgressModal;

// src/reset-progress-modal/ResetProgressModal.ts
var ResetProgressModal2 = class extends import_obsidian2.Modal {
  constructor(app, plugin2) {
    super(app);
    this.plugin = plugin2;
  }
  onOpen() {
    store_default.plugin.set(this.plugin);
    this.component = new ResetProgressModal_default({
      target: this.contentEl,
      props: {
        close: () => this.close(),
        closeAndReset: () => this.closeAndReset()
      }
    });
  }
  async closeAndReset() {
    await this.plugin.resetSettings();
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/seededAchievements.ts
var SEEDED_ACHIEVEMENTS = [
  {
    id: "notes-created:1",
    type: "notesCreated",
    name: "Your first note",
    description: "Create a note.",
    popupMessage: "You've created your first note. You're off to a great start!",
    requiredOccurenceCount: 1
  },
  {
    id: "notes-created:10",
    type: "notesCreated",
    name: "Note taker",
    description: "Create ten notes.",
    popupMessage: "You've created ten notes. Great job!",
    requiredOccurenceCount: 10
  },
  {
    id: "notes-created:100",
    type: "notesCreated",
    name: "Wordsmith",
    description: "Create one hundred notes.",
    popupMessage: "You've created one hundred notes! You're serious, aren't you?",
    requiredOccurenceCount: 100
  },
  {
    id: "notes-created:1000",
    type: "notesCreated",
    name: "Storyteller",
    description: "Create one thousand notes.",
    popupMessage: "You've created one thousand notes! That's impressive!",
    requiredOccurenceCount: 1e3
  },
  {
    id: "notes-deleted:10",
    type: "notesDeleted",
    name: "Taking out the trash",
    description: "Delete ten notes.",
    popupMessage: "You've deleted 10 notes. Way to keep your vault tidy!",
    requiredOccurenceCount: 10
  },
  {
    id: "internal-links-created:1",
    type: "internalLinksCreated",
    name: "Linking your thinking",
    description: "Create an internal link. You can type [[ to begin creating a internal link.",
    popupMessage: "You've created your first internal link. It's all coming together!",
    requiredOccurenceCount: 1
  },
  {
    id: "internal-links-created:10",
    type: "internalLinksCreated",
    name: "Making connections",
    description: "Create ten internal links.",
    popupMessage: "You've created 10 internal links. Your graph is looking great!",
    requiredOccurenceCount: 10
  },
  {
    id: "internal-links-created:100",
    type: "internalLinksCreated",
    name: "Conspiracy theorist",
    description: "Create one hundred internal links",
    popupMessage: "You've created 100 internal links. Your graph is starting to look like a conspiracy board...",
    requiredOccurenceCount: 100
  },
  {
    id: "internal-links-created:1000",
    type: "internalLinksCreated",
    name: "Air traffic controller",
    description: "Create one thousand internal links",
    popupMessage: "You've created 1000 internal links. If you haven't already, you should post your graph on the official Obsidian discord.",
    requiredOccurenceCount: 1e3
  },
  {
    id: "command-palette:open",
    type: "commandPaletteOpened",
    name: "Commander",
    description: "Open the command palette. You can find the hotkey to open the command palette in Settings - Hotkeys.",
    popupMessage: "You've opened the command palette. Way to take charge of your note taking!",
    requiredOccurenceCount: 1
  },
  {
    id: "switcher:open",
    type: "quickSwitcherOpened",
    name: "Quickly now",
    description: "Open the quick switcher.  You can find the hotkey to open the quick switcher in Settings - Hotkeys.",
    popupMessage: "You've opened the quick switcher. Wow that was fast!",
    requiredOccurenceCount: 1
  },
  {
    id: "callouts:1",
    type: "calloutsCreated",
    name: "Callouts",
    description: "Create a callout. You can find the hotkey to create a callout in Settings - Hotkeys.",
    popupMessage: "You've created a callout. Just felt like that needed to be called out.",
    requiredOccurenceCount: 1
  },
  {
    id: "heading-levels:1",
    type: "headingLevelsCreated",
    name: "Headings",
    description: "Create a heading. You can create a heading by adding a new line to a note and typing # Heading.",
    popupMessage: "You've created a heading. Your notes are looking more organized already!",
    requiredOccurenceCount: 1
  },
  {
    id: "heading-levels:3",
    type: "headingLevelsCreated",
    name: "Nested headings",
    description: "Create at least three levels of headings in a single note.",
    popupMessage: "You've created at least 3 levels of nested headings. Your notes look so organized!",
    requiredOccurenceCount: 3
  },
  {
    id: "tags-created:1",
    type: "tagsCreated",
    name: "Your first tag",
    description: "Create a tag. You can create a tag by typing #tag.",
    popupMessage: "You've created your first tag!",
    requiredOccurenceCount: 1
  },
  {
    id: "tags-created:5",
    type: "tagsCreated",
    name: "Tagging apprentice",
    description: "Create five unique tags.",
    popupMessage: "You've created five unique tags!",
    requiredOccurenceCount: 5
  },
  {
    id: "tags-created:10",
    type: "tagsCreated",
    name: "Tagging expert",
    description: "Create ten unique tags.",
    popupMessage: "You've created ten unique tags!",
    requiredOccurenceCount: 10
  }
];

// src/settings-tab/SettingsTab.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_default_slot_2(ctx) {
  let progress;
  let progress_value_value;
  let progress_max_value;
  return {
    c() {
      progress = element("progress");
      attr(progress, "class", "achievements-plugin__progress");
      progress.value = progress_value_value = Math.min(ctx[1].settings[ctx[2].type], ctx[2].requiredOccurenceCount);
      attr(progress, "max", progress_max_value = ctx[2].requiredOccurenceCount);
    },
    m(target, anchor) {
      insert(target, progress, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 2 && progress_value_value !== (progress_value_value = Math.min(ctx2[1].settings[ctx2[2].type], ctx2[2].requiredOccurenceCount))) {
        progress.value = progress_value_value;
      }
    },
    d(detaching) {
      if (detaching)
        detach(progress);
    }
  };
}
function create_each_block(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: ctx[2].name,
      description: ctx[2].description,
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & 34) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_default_slot_12(ctx) {
  let t;
  return {
    c() {
      t = text("Reset");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    d(detaching) {
      if (detaching)
        detach(t);
    }
  };
}
function create_default_slot2(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      variant: "destructive",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  button.$on("click", function() {
    if (is_function(ctx[0]))
      ctx[0].apply(this, arguments);
  });
  return {
    c() {
      create_component(button.$$.fragment);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & 32) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_fragment4(ctx) {
  let h20;
  let t1;
  let t2;
  let h21;
  let t4;
  let settingitem;
  let current;
  let each_value = SEEDED_ACHIEVEMENTS;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  settingitem = new SettingItem_default({
    props: {
      name: "Reset Progress",
      description: "Resets all achievement progress. THIS CANNOT BE UNDONE.",
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      h20 = element("h2");
      h20.textContent = "Achievements List";
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      h21 = element("h2");
      h21.textContent = "Danger Zone";
      t4 = space();
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      insert(target, h20, anchor);
      insert(target, t1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, t2, anchor);
      insert(target, h21, anchor);
      insert(target, t4, anchor);
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 2) {
        each_value = SEEDED_ACHIEVEMENTS;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(t2.parentNode, t2);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const settingitem_changes = {};
      if (dirty & 33) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(h20);
      if (detaching)
        detach(t1);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(t2);
      if (detaching)
        detach(h21);
      if (detaching)
        detach(t4);
      destroy_component(settingitem, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { openResetModal } = $$props;
  let plugin2;
  store_default.plugin.subscribe((p) => $$invalidate(1, plugin2 = p));
  $$self.$$set = ($$props2) => {
    if ("openResetModal" in $$props2)
      $$invalidate(0, openResetModal = $$props2.openResetModal);
  };
  return [openResetModal, plugin2];
}
var SettingsTab = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { openResetModal: 0 });
  }
};
var SettingsTab_default = SettingsTab;

// src/settings-tab/SettingsTab.ts
var AchievementsSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin2) {
    super(app, plugin2);
    this.plugin = plugin2;
  }
  display() {
    store_default.plugin.set(this.plugin);
    const { containerEl } = this;
    containerEl.empty();
    this.component = new SettingsTab_default({
      target: containerEl,
      props: {
        openResetModal: () => this.openResetModal()
      }
    });
  }
  openResetModal() {
    new ResetProgressModal2(this.app, this.plugin).open();
  }
};

// node_modules/monkey-around/mjs/index.js
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const original = obj[method], hadOwn = obj.hasOwnProperty(method);
  let current = createWrapper(original);
  if (original)
    Object.setPrototypeOf(current, original);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, original || Function);
  }
}

// src/commands.ts
function onCommandTrigger(id, cb) {
  const uninstallCommand = around(this.app.commands, {
    executeCommand(originalMethod) {
      return function(...args) {
        if (args[0].id === id) {
          cb();
        }
        const result = originalMethod && originalMethod.apply(this, args);
        return result;
      };
    }
  });
  return uninstallCommand;
}

// src/markdownHelpers.ts
function fileHasCallout(cache) {
  if (!cache.sections) {
    return false;
  }
  return cache.sections.some((section) => section.type === "callout");
}
function getFileHeadingLevelsCount(cache) {
  if (!cache.headings) {
    return 0;
  }
  const levels = cache.headings.reduce((obj, { level }) => {
    obj[level] = true;
    return obj;
  }, {});
  return Object.keys(levels).length;
}

// src/achievements-view/AchievementsView.ts
var import_obsidian4 = require("obsidian");

// src/array-utils/sort.ts
function sortAchievements(arr, plugin2) {
  const result = [...arr];
  return result.sort((a, b) => {
    const achievedCriteria = (plugin2.settings.achievedAchievementIDs.includes(a.id) ? 1 : 0) - (plugin2.settings.achievedAchievementIDs.includes(b.id) ? 1 : 0);
    if (achievedCriteria !== 0) {
      return achievedCriteria;
    }
    const aProgress = plugin2.settings[a.type] / a.requiredOccurenceCount;
    const bProgress = plugin2.settings[b.type] / b.requiredOccurenceCount;
    const progressCriteria = bProgress - aProgress;
    if (progressCriteria !== 0) {
      return progressCriteria;
    }
    const requiredOccurenceCountCriteria = a.requiredOccurenceCount - b.requiredOccurenceCount;
    if (requiredOccurenceCountCriteria !== 0) {
      return requiredOccurenceCountCriteria;
    }
    return a.name.localeCompare(b.name);
  });
}

// src/achievements-view/AchievementsView.svelte
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_default_slot3(ctx) {
  let progress;
  let progress_value_value;
  let progress_max_value;
  let t;
  return {
    c() {
      progress = element("progress");
      t = space();
      attr(progress, "class", "achievements-plugin__progress");
      progress.value = progress_value_value = Math.min(ctx[0].settings[ctx[2].type], ctx[2].requiredOccurenceCount);
      attr(progress, "max", progress_max_value = ctx[2].requiredOccurenceCount);
    },
    m(target, anchor) {
      insert(target, progress, anchor);
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & 3 && progress_value_value !== (progress_value_value = Math.min(ctx2[0].settings[ctx2[2].type], ctx2[2].requiredOccurenceCount))) {
        progress.value = progress_value_value;
      }
      if (dirty & 2 && progress_max_value !== (progress_max_value = ctx2[2].requiredOccurenceCount)) {
        attr(progress, "max", progress_max_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(progress);
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block2(ctx) {
  let settingitem;
  let current;
  settingitem = new SettingItem_default({
    props: {
      name: ctx[2].name,
      description: ctx[2].description,
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(settingitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(settingitem, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const settingitem_changes = {};
      if (dirty & 2)
        settingitem_changes.name = ctx2[2].name;
      if (dirty & 2)
        settingitem_changes.description = ctx2[2].description;
      if (dirty & 35) {
        settingitem_changes.$$scope = { dirty, ctx: ctx2 };
      }
      settingitem.$set(settingitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(settingitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(settingitem, detaching);
    }
  };
}
function create_fragment5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let plugin2;
  let achievements;
  store_default.plugin.subscribe((p) => {
    $$invalidate(0, plugin2 = p);
    $$invalidate(1, achievements = sortAchievements(SEEDED_ACHIEVEMENTS, plugin2));
  });
  return [plugin2, achievements];
}
var AchievementsView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {});
  }
};
var AchievementsView_default = AchievementsView;

// src/achievements-view/AchievementsView.ts
var VIEW_TYPE_ACHIEVEMENTS = "achievements-view";
var AchievementsView2 = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin2) {
    super(leaf);
    this.plugin = plugin2;
  }
  getViewType() {
    return VIEW_TYPE_ACHIEVEMENTS;
  }
  getDisplayText() {
    return "Achievements";
  }
  getIcon() {
    return "trophy";
  }
  async onOpen() {
    store_default.plugin.set(this.plugin);
    this.component = new AchievementsView_default({
      target: this.contentEl
    });
  }
  async onClose() {
    this.component.$destroy();
  }
};

// src/main.ts
var AchievementsPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.uninstallCommands = [];
  }
  async onload() {
    console.log("loading Achievements plugin");
    await this.loadSettings();
    this.setupInternalCounts();
    this.registerView(VIEW_TYPE_ACHIEVEMENTS, (leaf) => new AchievementsView2(leaf, this));
    this.registerEvent(this.app.metadataCache.on("changed", (file, data, cache) => {
      this.handleFileCreateUpdateDelete(file, cache);
    }));
    this.registerEvent(this.app.metadataCache.on("deleted", (file, _prevCache) => this.handleFileCreateUpdateDelete(file)));
    this.uninstallCommands.push(onCommandTrigger("command-palette:open", async () => {
      this.settings.commandPaletteOpened += 1;
      this.getNewAchievementMaybe("commandPaletteOpened");
      await this.saveSettings();
    }));
    this.uninstallCommands.push(onCommandTrigger("switcher:open", async () => {
      this.settings.quickSwitcherOpened += 1;
      this.getNewAchievementMaybe("quickSwitcherOpened");
      await this.saveSettings();
    }));
    this.addCommand({
      id: "show-achievements-view",
      name: "Show Achievements Panel",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new AchievementsSettingTab(this.app, this));
  }
  onunload() {
    console.log("unloading Achievements plugin");
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_ACHIEVEMENTS);
    this.uninstallCommands.forEach((uninstallCommand) => {
      uninstallCommand();
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    store_default.plugin.set(this);
  }
  async resetSettings() {
    this.settings = { ...DEFAULT_SETTINGS };
    await this.saveSettings();
  }
  setupInternalCounts() {
    this.internalCounts = {
      noteCount: this.getMarkdownFilesCount(),
      internalLinkCount: this.getInternalLinksCount(),
      tagCount: this.getTagsCount()
    };
  }
  async activateView() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_ACHIEVEMENTS);
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: VIEW_TYPE_ACHIEVEMENTS,
      active: true
    });
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(VIEW_TYPE_ACHIEVEMENTS)[0]);
  }
  getMarkdownFilesCount() {
    return this.app.vault.getMarkdownFiles().length;
  }
  getInternalLinksCount() {
    return this.app.fileManager.getAllLinkResolutions().length;
  }
  getTagsCount() {
    const tagsObj = this.app.metadataCache.getTags();
    const baseTagsArr = Object.entries(tagsObj).filter(([key]) => !key.includes("/"));
    return baseTagsArr.reduce((prev, curr) => prev + curr[1], 0);
  }
  async handleFileCreateUpdateDelete(file, cache) {
    const currNoteCount = this.getMarkdownFilesCount();
    const currInternalLinkCount = this.getInternalLinksCount();
    const currTagsCount = this.getTagsCount();
    if (currNoteCount > this.internalCounts.noteCount) {
      this.settings.notesCreated += currNoteCount - this.internalCounts.noteCount;
      this.internalCounts.noteCount = currNoteCount;
      this.getNewAchievementMaybe("notesCreated");
    }
    if (currNoteCount < this.internalCounts.noteCount) {
      this.settings.notesDeleted += this.internalCounts.noteCount - currNoteCount;
      this.internalCounts.noteCount = currNoteCount;
      this.getNewAchievementMaybe("notesDeleted");
    }
    if (currInternalLinkCount > this.internalCounts.internalLinkCount) {
      this.settings.internalLinksCreated += currInternalLinkCount - this.internalCounts.internalLinkCount;
      this.internalCounts.internalLinkCount = currInternalLinkCount;
      this.getNewAchievementMaybe("internalLinksCreated");
    }
    if (currTagsCount > this.internalCounts.tagCount) {
      this.settings.tagsCreated += currTagsCount - this.internalCounts.tagCount;
      this.internalCounts.tagCount = currTagsCount;
      this.getNewAchievementMaybe("tagsCreated");
    }
    if (cache) {
      if (this.settings.calloutsCreated === 0 && fileHasCallout(cache)) {
        this.settings.calloutsCreated = 1;
        this.getNewAchievementMaybe("calloutsCreated");
      }
      const headingLevelsCount = getFileHeadingLevelsCount(cache);
      if (headingLevelsCount > this.settings.headingLevelsCreated) {
        this.settings.headingLevelsCreated = headingLevelsCount;
        this.getNewAchievementMaybe("headingLevelsCreated");
      }
    }
    await this.saveSettings();
  }
  getNewAchievementMaybe(type) {
    const newAchievements = SEEDED_ACHIEVEMENTS.filter((achievement) => achievement.type === type && this.settings[type] >= achievement.requiredOccurenceCount && !this.settings.achievedAchievementIDs.includes(achievement.id));
    if (newAchievements.length > 0) {
      newAchievements.forEach((achievement) => {
        this.settings.achievedAchievementIDs.push(achievement.id);
        new import_obsidian5.Notice(`${achievement.name}
${achievement.popupMessage}`);
      });
    }
  }
};
